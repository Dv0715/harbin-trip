<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å“ˆçˆ¾æ¿±æ”¯ç·šï½œæ»‘é›ªå¤§å†’éšª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #0a0c12; color: white; font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; }
        .snow-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(to bottom, #d6e2f0, #e0f2f7), url('https://i.imgur.com/P5j1w1h.png'), url('https://i.imgur.com/O61WJ7b.png');
            background-repeat: no-repeat; background-size: 100% 100%, 150% auto, 120% auto; background-position: center bottom; z-index: -1;
        }
        #gameCanvas { background: none; display: block; margin: 0 auto; cursor: crosshair; } 
        .ui-panel { 
            position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: none; 
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); 
        }
        .btn-action { 
            pointer-events: auto; background: linear-gradient(145deg, #007bff, #0056b3); color: white; padding: 14px 40px; border-radius: 99px; font-weight: bold; font-size: 1.25rem; letter-spacing: 1px; transition: all 0.2s ease-in-out; box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4); border: none; cursor: pointer;
        }
        .btn-action:hover { transform: translateY(-3px); box-shadow: 0 12px 25px rgba(0, 123, 255, 0.5); }
        .btn-action:active { transform: scale(0.95); box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3); }
        #charSelect { width: 90%; max-width: 580px; margin: 10px auto 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; overflow: visible; }
        .card-container { width: 22%; aspect-ratio: 152 / 260; cursor: pointer; position: relative; perspective: 1200px; }
        .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1); transform-style: preserve-3d; }
        .card-container.is-selected .card-inner { transform: rotateY(180deg); }
        .card-container.is-selected { filter: drop-shadow(0 0 15px #e5a400); transform: scale(1.15); z-index: 10; }
        .card-front, .card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 12px; background: none !important; overflow: hidden; }
        .card-front { background: linear-gradient(135deg, #1e293b, #0f172a); }
        .card-back { background: linear-gradient(135deg, #007bff, #0056b3); transform: rotateY(180deg); }
        .card-img { width: 100%; height: 100%; object-fit: cover; opacity: 1; display: block; }
        .card-label { position: absolute; bottom: 0; width: 100%; background: rgba(0,0,0,0.75); color: white; font-size: 11px; padding: 4px 0; backdrop-filter: blur(3px); font-weight: 600; }
        #liveScore { font-family: 'Space Mono', monospace; font-size: 1.5rem; font-weight: bold; color: #6edaff; text-shadow: 0 0 8px rgba(110, 218, 255, 0.5); }
        .score-panel { position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px); border: 1px solid rgba(50, 184, 236, 0.2); padding: 6px 16px; border-radius: 99px; z-index: 1000; display: flex; align-items: center; gap: 8px; }
        .score-panel::before { content: "åˆ†æ•¸"; font-size: 10px; font-weight: 900; color: rgba(255, 255, 255, 0.6); letter-spacing: 1px; }
        h1.title-bounce { font-weight: 900; font-style: italic; color: #93c5fd; text-shadow: 2px 2px 0px #1e3a8a, 4px 4px 15px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

<div class="snow-bg"></div>

<div id="uiStart" class="ui-panel pointer-events-auto">
    <h1 class="text-5xl font-black italic mb-3 text-blue-300 title-bounce">æ»‘é›ªæŒ‘æˆ°GOï¼ğŸ§Š</h1>
    <p class="text-gray-300 mb-10 text-sm tracking-widest uppercase">â„ï¸ Yabuli Special Edition â„ï¸</p>
    <div id="charSelect"></div>
    <button onclick="start()" class="btn-action text-xl px-12 py-4">é–‹å§‹æ»‘é›ª</button>
</div>

<div id="uiOver" class="ui-panel hidden pointer-events-auto">
    <h2 class="text-6xl font-black text-red-400 mb-4 italic">æ‘”å€’äº†ï¼</h2>
    <p class="text-2xl mb-10">æœ€çµ‚å¾—åˆ†: <span id="finalScore" class="text-yellow-300">0</span></p>
    <button onclick="location.reload()" class="btn-action bg-red-600">é‡æ–°æŒ‘æˆ°</button>
</div>

<div class="score-panel">
    <span id="liveScore">0</span>
</div>

<canvas id="gameCanvas"></canvas>

<script>
let items = [], particles = [], obstacles = [];
    let powerUpTimer = 0, stormMode = false, stormTimer = 0, friction = 0.12; 
    let selectedIdx = 4, running = false, score = 0, frame = 0, speed = 7;
    let px, py = 150, tx;
    let fogAlpha = 0;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const CHARS = [
        { name: "çˆ¸", file: "1", boardType: "double", size: 55, faceY: 0.562, faceScale: 0.45, faceX: -0.01 },
        { name: "åª½", file: "2", boardType: "double", size: 55, faceY: 0.549, faceScale: 0.443, faceX: 0.005 },
        { name: "å“¥", file: "3", boardType: "single", size: 55, faceY: 0.57, faceScale: 0.45, faceX: -0.01 },
        { name: "è¨€", file: "4", boardType: "double", size: 55, faceY: 0.62, faceScale: 0.45, faceX: 0.007 },
        { name: "å¦¹", file: "5", boardType: "double", size: 55, faceY: 0.525, faceScale: 0.45, faceX: 0.005 },
        { name: "å¼Ÿ", file: "6", boardType: "single", size: 55, faceY: 0.558, faceScale: 0.45, faceX: -0.04 },
        { name: "Vivi", file: "7", boardType: "single", size: 55, faceY: 0.602, faceScale: 0.45, faceX: -0.001 }
    ];

    const FACES = ['n', 's', 'h', 'e', 'd']; 
    const OBSTACLE_FILES = ['1.webp', '2.webp', '3.webp'];
    const charImages = {}, obsImages = {};
    const OBSTACLE_CONFIG = {
        '1.webp': { w: 70, h: 60, r: 35 }, 
        '2.webp': { w: 50, h: 50, r: 35 }, 
        '3.webp': { w: 70, h: 90, r: 35 }  
    };

    function preloadAssets() {
        CHARS.forEach(c => {
            const mainImg = new Image();
            mainImg.src = `images/ski/${c.file}.webp`;
            charImages[c.file] = mainImg;

            FACES.forEach(f => {
                const img = new Image();
                img.src = `images/ski/${c.file}_${f}.webp`;
                charImages[`${c.file}_${f}`] = img;
            });
        });
        OBSTACLE_FILES.forEach(file => {
            const img = new Image(); 
            img.src = `images/obs/${file}`;
            obsImages[file] = img;
        });
    }
    preloadAssets();

    function initCharSelect() {
        const menu = document.getElementById('charSelect');
        menu.innerHTML = CHARS.map((c, i) => `
            <div class="card-container ${i === selectedIdx ? 'is-selected' : ''}" onclick="selectChar(${i})" id="char-card-${i}">
                <div class="card-inner">
                    <div class="card-front"><img src="images/char/${c.file}.webp" class="card-img"><div class="card-label">${c.name}</div></div>
                    <div class="card-back"><img src="images/char/${c.file}_real.webp" class="card-img" onerror="this.src='https://placehold.co/152x260/0056b3/white?text=${c.name}Real'"><div class="card-label">READY!</div></div>
                </div>
            </div>
        `).join('');
    }

    window.selectChar = (i) => {
        document.querySelectorAll('.card-container').forEach(el => el.classList.remove('is-selected'));
        selectedIdx = i;
        document.getElementById(`char-card-${i}`).classList.add('is-selected');
    };

    function resize() {
        canvas.width = Math.min(window.innerWidth, 500);
        canvas.height = window.innerHeight;
        px = tx = canvas.width / 2;
    }

    function start() {
        document.getElementById('uiStart').classList.add('hidden');
        running = true; score = 0; speed = 7; obstacles = []; items = []; particles = [];
        loop();
    }

    const move = (ex) => {
        if(!running) return;
        const r = canvas.getBoundingClientRect();
        tx = Math.max(40, Math.min(canvas.width-40, (ex - r.left) * (canvas.width / r.width)));
    };
    window.addEventListener('mousemove', e => move(e.clientX));
    window.addEventListener('touchmove', e => move(e.touches[0].clientX));

    function loop() {
        if(!running) return;
        frame++; 
        
        // 1. ç‰©ç†æ‰‹æ„Ÿ
        if (powerUpTimer > 0) {
            powerUpTimer--; speed += 0.05; friction = 0.2;
        } else if (stormMode) {
            speed += 0.03; friction = 0.06;
        } else {
            friction = 0.12;
        }
        px += (tx - px) * friction; 
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 2. æš´é¢¨é›ªé‚è¼¯
        stormTimer++;
        if (stormTimer % 1200 === 0) stormMode = true; 
        if (stormMode && stormTimer % 1200 === 300) stormMode = false; 

        // é€Ÿåº¦ç·š
        ctx.strokeStyle = '#c5e2f7'; ctx.lineWidth = 2;
        for(let i=0; i<6; i++) {
            let ly = (frame * speed * 0.8 + i * 150) % (canvas.height + 150);
            ctx.beginPath(); ctx.moveTo(i * canvas.width / 5, ly - 50); ctx.lineTo(i * canvas.width / 5, ly + 50); ctx.stroke();
        }

        // 3. é“å…· (ç³–è‘«è˜†)
        if(frame % 200 === 0) items.push({ x: Math.random() * (canvas.width - 80) + 40, y: canvas.height + 100, type: 'ğŸ¡' });
        items.forEach((item, i) => {
            item.y -= speed;
            ctx.font = '40px serif'; ctx.textAlign = 'center';
            ctx.fillText(item.type, item.x, item.y);
            if(Math.hypot(px - item.x, py - item.y) < 40) { items.splice(i, 1); powerUpTimer = 90; score += 10; }
            if(item.y < -100) items.splice(i, 1);
        });

        // 4. éšœç¤™ç‰©èˆ‡ç¢°æ’
        if(frame % Math.max(15, 40 - Math.floor(speed * 0.7)) === 0) {
            const file = OBSTACLE_FILES[Math.floor(Math.random() * OBSTACLE_FILES.length)];
            obstacles.push({ x: Math.random() * (canvas.width - 80) + 40, y: canvas.height + 100, file: file });
        }
        obstacles.forEach((o, i) => {
            o.y -= speed;
            const config = OBSTACLE_CONFIG[o.file] || { w: 60, h: 60, r: 30 };
            const img = obsImages[o.file];
            ctx.save();
            if (powerUpTimer > 0 && Math.hypot(px - o.x, py - o.y) < config.r + 20) ctx.globalAlpha = 0.3;
            if (img && img.complete) ctx.drawImage(img, o.x - config.w / 2, o.y - config.h / 2, config.w, config.h);
            ctx.restore();
            if (powerUpTimer <= 0 && Math.hypot(px - o.x, py - o.y) < config.r) {
                running = false; document.getElementById('uiOver').classList.remove('hidden');
                document.getElementById('finalScore').textContent = score;
            }
            if(o.y < -150) { obstacles.splice(i, 1); score++; document.getElementById('liveScore').textContent = score; if(score % 5 === 0) speed += 0.2; }
        });

        // 5. ç¹ªè£½ç©å®¶ (å«è¡¨æƒ…ç–ŠåŠ )
        updateParticlesLogic();
        ctx.save(); 
        ctx.translate(px, py);
        let tilt = Math.max(-0.2, Math.min(0.2, (tx - px) * 0.05));
        let tipSwing = tilt * 30;
        drawParticlesRelative();
        
        // é›ªæ¿
        ctx.save(); ctx.strokeStyle = '#3D3333'; ctx.lineWidth = (CHARS[selectedIdx].boardType === 'double') ? 10 : 25; ctx.lineCap = 'round';
        if (CHARS[selectedIdx].boardType === 'double') {
            const gap = 10;
            ctx.beginPath(); ctx.moveTo(-gap, -25); ctx.lineTo(-gap + tipSwing, 25); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(gap, -25); ctx.lineTo(gap + tipSwing, 25); ctx.stroke();
            if (Math.abs(tilt) > 0.05) { addParticle(-gap + tipSwing, 12, -2, 2); addParticle(gap + tipSwing, 12, 2, 2); }
        } else {
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(tipSwing, 25); ctx.stroke();
            if (Math.abs(tilt) > 0.05) addParticle(tipSwing, 25, -tilt * 10, 2);
        }
        ctx.restore();

// B. ç¹ªè£½èº«é«”èˆ‡äº”å®˜
ctx.save();
let breath = Math.sin(frame * 0.15) * 2; 
ctx.rotate(tilt * 0.5); 

const charData = CHARS[selectedIdx];
const charID = charData.file;
// ğŸ’¡ ç¢ºä¿é€™æ®µé‚è¼¯åœ¨ç¹ªè£½å‰åŸ·è¡Œ
let faceSuffix = (!running) ? "d" : (powerUpTimer > 0) ? "e" : (stormMode) ? "s" : (score > 0 && score % 10 <= 2) ? "h" : "n";

const bodyImg = charImages[charID];
const faceImg = charImages[`${charID}_${faceSuffix}`];
const drawW = charData.size || 70;
const drawH = (260 / 152) * drawW; // é€™è£¡æ”¹å› 260/152 ä»¥ç¬¦åˆä½ çš„åŸåœ–æ¯”ä¾‹

if (bodyImg && bodyImg.complete) {
    // ç•«èº«é«”
    ctx.drawImage(bodyImg, -drawW/2, -drawH + 5 + breath, drawW, drawH - breath);
    
    // ç•«äº”å®˜ç–ŠåŠ  (faceX ä¿®æ­£ç‰ˆ)
    if (faceImg && faceImg.complete && faceSuffix !== 'n') {
        const faceScale = charData.faceScale || 0.6;
        const faceW = drawW * faceScale;
        const faceH = faceImg.height * (faceW / faceImg.width);
        
        const faceYPos = -drawH * (charData.faceY || 0.75);
        const faceXPos = drawW * (charData.faceX || 0); // ğŸ’¡ æ°´å¹³ä½ç§»

        ctx.drawImage(
            faceImg, 
            faceXPos - faceW / 2, 
            faceYPos - faceH / 2 + breath, 
            faceW, 
            faceH
        );
    }
}
ctx.restore(); // çµæŸå‘¼å¸èˆ‡æ—‹è½‰
        
        // å›ºå®šå™¨
        ctx.fillStyle = '#222222'; let bindSwing = tipSwing * 0.6;
        if (charData.boardType === 'double') {
            ctx.beginPath(); ctx.roundRect(-16 + bindSwing, -5, 14, 12, 4); ctx.fill();
            ctx.beginPath(); ctx.roundRect(2 + bindSwing, -5, 14, 12, 4); ctx.fill();
        } else {
            ctx.beginPath(); ctx.roundRect(-7 + bindSwing, -4, 14, 9, 3); ctx.fill();
        }
        ctx.restore();

        // 6. æš´é¢¨é›ªèˆ‡éœ§æ°£ç‰¹æ•ˆ (æœ€ä¸Šå±¤)
        if (stormMode) {
            if (fogAlpha < 0.75) fogAlpha += 0.015;
            for(let i=0; i<15; i++) addStormParticle();
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width*0.15, canvas.width/2, canvas.height/2, canvas.width*0.9);
            grad.addColorStop(0, "rgba(255, 255, 255, 0)"); grad.addColorStop(1, `rgba(255, 255, 255, ${fogAlpha})`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        } else if (fogAlpha > 0) {
            fogAlpha -= 0.02;
        }

        requestAnimationFrame(loop);
    }

    function addParticle(x, y, vx, vy) { if (particles.length < 150) particles.push({ x, y, vx, vy, life: 30, alpha: 1, isStorm: false }); }
    function addStormParticle() {
        if (particles.length < 350) particles.push({ x: Math.random() * (canvas.width + 600) - 200, y: Math.random() * -200, vx: -15 - Math.random() * 20, vy: 20 + Math.random() * 15, life: 30, alpha: 0.3 + Math.random() * 0.5, isStorm: true, size: 1 + Math.random() * 3 });
    }
    function updateParticlesLogic() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i]; p.x += p.vx; p.y += p.vy;
            if (!p.isStorm) p.y -= speed * 0.5;
            p.life--; p.alpha = p.life / 30; if (p.life <= 0) particles.splice(i, 1);
        }
    }
    function drawParticlesRelative() {
        particles.forEach(p => {
            ctx.save(); ctx.globalAlpha = p.alpha; ctx.strokeStyle = 'white'; ctx.fillStyle = 'white';
            if (p.isStorm) { ctx.lineWidth = p.size; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + p.vx * 0.8, p.y + p.vy * 0.8); ctx.stroke(); }
            else { ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        });
    }

    window.onresize = resize; resize(); initCharSelect();
</script>
</body>
</html>