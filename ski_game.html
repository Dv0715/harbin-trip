<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å“ˆçˆ¾æ¿±æ”¯ç·šï½œæ»‘é›ªå¤§å†’éšª</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #0a0c12; color: white; font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; }
        .snow-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-image: linear-gradient(to bottom, #d6e2f0, #e0f2f7), url('https://i.imgur.com/P5j1w1h.png'), url('https://i.imgur.com/O61WJ7b.png');
            background-repeat: no-repeat; background-size: 100% 100%, 150% auto, 120% auto; background-position: center bottom; z-index: -1;
        }
        #gameCanvas { background: none; display: block; margin: 0 auto; cursor: crosshair; } 
        .ui-panel { 
            position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: none; 
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); 
        }
        .btn-action { 
            pointer-events: auto; background: linear-gradient(145deg, #007bff, #0056b3); color: white; padding: 14px 40px; border-radius: 99px; font-weight: bold; font-size: 1.25rem; letter-spacing: 1px; transition: all 0.2s ease-in-out; box-shadow: 0 8px 20px rgba(0, 123, 255, 0.4); border: none; cursor: pointer;
        }
        .btn-action:hover { transform: translateY(-3px); box-shadow: 0 12px 25px rgba(0, 123, 255, 0.5); }
        .btn-action:active { transform: scale(0.95); box-shadow: 0 4px 10px rgba(0, 123, 255, 0.3); }
        #charSelect { width: 90%; max-width: 580px; margin: 10px auto 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; overflow: visible; }
        .card-container { width: 22%; aspect-ratio: 152 / 260; cursor: pointer; position: relative; perspective: 1200px; }
        .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1); transform-style: preserve-3d; }
        .card-container.is-selected .card-inner { transform: rotateY(180deg); }
        .card-container.is-selected { filter: drop-shadow(0 0 15px #e5a400); transform: scale(1.15); z-index: 10; }
        .card-front, .card-back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 12px; background: none !important; overflow: hidden; }
        .card-front { background: linear-gradient(135deg, #1e293b, #0f172a); }
        .card-back { background: linear-gradient(135deg, #007bff, #0056b3); transform: rotateY(180deg); }
        .card-img { width: 100%; height: 100%; object-fit: cover; opacity: 1; display: block; }
        .card-label { position: absolute; bottom: 0; width: 100%; background: rgba(0,0,0,0.75); color: white; font-size: 11px; padding: 4px 0; backdrop-filter: blur(3px); font-weight: 600; }
        #liveScore { font-family: 'Space Mono', monospace; font-size: 1.5rem; font-weight: bold; color: #6edaff; text-shadow: 0 0 8px rgba(110, 218, 255, 0.5); }
        .score-panel { position: fixed; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px); border: 1px solid rgba(50, 184, 236, 0.2); padding: 6px 16px; border-radius: 99px; z-index: 1000; display: flex; align-items: center; gap: 8px; transition: transform 0.2s; }
        .score-panel::before { content: "åˆ†æ•¸"; font-size: 10px; font-weight: 900; color: rgba(255, 255, 255, 0.6); letter-spacing: 1px; }
        h1.title-bounce { font-weight: 900; font-style: italic; color: #93c5fd; text-shadow: 2px 2px 0px #1e3a8a, 4px 4px 15px rgba(0,0,0,0.5); }
        
        @keyframes score-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #ffeb3b; }
            100% { transform: scale(1); }
        }
        .score-bounce { animation: score-pop 0.3s ease-out; }


canvas {
    touch-action: none; /* ğŸ’¡ ç¦æ­¢ç€è¦½å™¨è™•ç†æ‰€æœ‰æ‰‹å‹¢ï¼Œå…¨æ¬Šäº¤çµ¦ JavaScript */
    user-select: none;  /* é˜²æ­¢é•·æŒ‰é¸å–æ–‡å­— */
    -webkit-tap-highlight-color: rgba(0,0,0,0); /* ç§»é™¤ iOS é»æ“Šç°è‰²æ–¹å¡Š */
}


    </style>
</head>
<body>

<div class="snow-bg"></div>
<div id="uiStart" class="ui-panel pointer-events-auto">
    <h1 class="text-5xl font-black italic mb-3 text-blue-300 title-bounce">æ»‘é›ªæŒ‘æˆ°GOï¼ğŸ§Š</h1>
    <p class="text-gray-300 mb-10 text-sm tracking-widest uppercase">â„ï¸ Yabuli Special Edition â„ï¸</p>
    <div id="charSelect"></div>
    <button onclick="start()" class="btn-action text-xl px-12 py-4">é–‹å§‹æ»‘é›ª</button>
</div>
<div id="uiOver" class="ui-panel hidden pointer-events-auto">
    <h2 class="text-6xl font-black text-red-400 mb-4 italic">æ‘”å€’äº†ï¼</h2>
    <p class="text-2xl mb-10">æœ€çµ‚å¾—åˆ†: <span id="finalScore" class="text-yellow-300">0</span></p>
    <button onclick="location.reload()" class="btn-action bg-red-600">é‡æ–°æŒ‘æˆ°</button>
</div>
<div class="score-panel"><span id="liveScore">0</span></div>
<canvas id="gameCanvas"></canvas>

<script>
    let items = [], particles = [], obstacles = [];
    let powerUpTimer = 0, stormMode = false, stormTimer = 0, friction = 0.12; 
    let selectedIdx = 4, running = false, score = 0, frame = 0, speed = 7, px, py = 150, tx, fogAlpha = 0;





    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const CHARS = [
        { name: "çˆ¸", file: "1", boardType: "double", size: 55, faceY: 0.562, faceScale: 0.5, faceX: -0.01 },
        { name: "åª½", file: "2", boardType: "double", size: 55, faceY: 0.549, faceScale: 0.5, faceX: 0.005 },
        { name: "å“¥", file: "3", boardType: "single", size: 55, faceY: 0.575, faceScale: 0.49, faceX: -0.01 },
        { name: "è¨€", file: "4", boardType: "double", size: 55, faceY: 0.62, faceScale: 0.5, faceX: 0.007 },
        { name: "å¦¹", file: "5", boardType: "double", size: 55, faceY: 0.525, faceScale: 0.5, faceX: 0.005 },
        { name: "å¼Ÿ", file: "6", boardType: "single", size: 55, faceY: 0.569, faceScale: 0.496, faceX: -0.04 },
        { name: "Vivi", file: "7", boardType: "single", size: 55, faceY: 0.6065, faceScale: 0.5, faceX: -0.005 }
    ];

    const FACES = ['n', 's', 'h', 'e', 'd']; 
    const OBSTACLE_FILES = ['1.webp', '2.webp', '3.webp'];
    const charImages = {}, obsImages = {};
    const OBSTACLE_CONFIG = {
        '1.webp': { w: 70, h: 60, r: 35 }, '2.webp': { w: 50, h: 50, r: 35 }, '3.webp': { w: 70, h: 90, r: 35 }
    };

    function preloadAssets() {
        CHARS.forEach(c => {
            const mainImg = new Image(); mainImg.src = `images/ski/${c.file}.webp`;
            charImages[c.file] = mainImg;
            FACES.forEach(f => {
                const img = new Image(); img.src = `images/ski/${c.file}_${f}.webp`;
                charImages[`${c.file}_${f}`] = img;
            });
        });
        OBSTACLE_FILES.forEach(file => {
            const img = new Image(); img.src = `images/obs/${file}`;
            obsImages[file] = img;
        });
    }
    preloadAssets();

    function updateScore(points) {
        score += points;
        const scoreEl = document.querySelector('.score-panel');
        const liveScoreEl = document.getElementById('liveScore');
        if (liveScoreEl) liveScoreEl.textContent = score;
        if (scoreEl) {
            scoreEl.classList.remove('score-bounce');
            void scoreEl.offsetWidth;
            scoreEl.classList.add('score-bounce');
        }
    }

    function initCharSelect() {
        const menu = document.getElementById('charSelect');
        menu.innerHTML = CHARS.map((c, i) => `
            <div class="card-container ${i === selectedIdx ? 'is-selected' : ''}" onclick="selectChar(${i})" id="char-card-${i}">
                <div class="card-inner">
                    <div class="card-front"><img src="images/char/${c.file}.webp" class="card-img"><div class="card-label">${c.name}</div></div>
                    <div class="card-back"><img src="images/char/${c.file}_real.webp" class="card-img" onerror="this.src='https://placehold.co/152x260/0056b3/white?text=${c.name}Real'"><div class="card-label">READY!</div></div>
                </div>
            </div>
        `).join('');
    }

    window.selectChar = (i) => {
        document.querySelectorAll('.card-container').forEach(el => el.classList.remove('is-selected'));
        selectedIdx = i;
        document.getElementById(`char-card-${i}`).classList.add('is-selected');
    };

    function resize() {
        canvas.width = Math.min(window.innerWidth, 500); canvas.height = window.innerHeight;
        px = tx = canvas.width / 2;
    }

    function start() {
        document.getElementById('uiStart').classList.add('hidden');
        running = true; score = 0; speed = 7; obstacles = []; items = []; particles = [];
        loop();
    }

    const move = (ex) => {
        if(!running) return;
        const r = canvas.getBoundingClientRect();
        tx = Math.max(40, Math.min(canvas.width-40, (ex - r.left) * (canvas.width / r.width)));
    };
    window.addEventListener('mousemove', e => move(e.clientX));
    window.addEventListener('touchmove', e => move(e.touches[0].clientX));

    function loop() {
        if(!running) return;
        frame++; 
        
        if (powerUpTimer > 0) { powerUpTimer--; speed += 0.05; friction = 0.2; }
        else if (stormMode) { speed += 0.03; friction = 0.06; }
        else { friction = 0.12; }
        
        px += (tx - px) * friction; 
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        stormTimer++;
        if (stormTimer % 1200 === 0) stormMode = true; 
        if (stormMode && stormTimer % 1200 === 300) stormMode = false; 

        // é€Ÿåº¦ç·š
        ctx.strokeStyle = '#c5e2f7'; ctx.lineWidth = 2;
        for(let i=0; i<6; i++) {
            let ly = (frame * speed * 0.8 + i * 150) % (canvas.height + 150);
            ctx.beginPath(); ctx.moveTo(i * canvas.width / 5, ly - 50); ctx.lineTo(i * canvas.width / 5, ly + 50); ctx.stroke();
        }

        // ğŸ’¡ ä¿®æ­£é“å…·ç”Ÿæˆèˆ‡ç¹ªè£½é‚è¼¯
        if(frame % 200 === 0) items.push({ x: Math.random() * (canvas.width - 80) + 40, y: canvas.height + 100, type: 'ğŸ¡' });
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.y -= speed;
            ctx.font = '40px serif'; ctx.textAlign = 'center';
            ctx.fillText(item.type, item.x, item.y);
            if(Math.hypot(px - item.x, py - item.y) < 40) { 
                items.splice(i, 1); powerUpTimer = 90; updateScore(10); 
            } else if(item.y < -100) {
                items.splice(i, 1);
            }
        }

        // éšœç¤™ç‰©
        if(frame % Math.max(15, 40 - Math.floor(speed * 0.7)) === 0) {
            const file = OBSTACLE_FILES[Math.floor(Math.random() * OBSTACLE_FILES.length)];
            obstacles.push({ x: Math.random() * (canvas.width - 80) + 40, y: canvas.height + 100, file: file });
        }
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let o = obstacles[i];
            o.y -= speed;
            const config = OBSTACLE_CONFIG[o.file] || { w: 60, h: 60, r: 35 };
            const img = obsImages[o.file];
            ctx.save();
            if (powerUpTimer > 0 && Math.hypot(px - o.x, py - o.y) < config.r + 20) ctx.globalAlpha = 0.3;
            if (img && img.complete) ctx.drawImage(img, o.x - config.w / 2, o.y - config.h / 2, config.w, config.h);
            ctx.restore();
            if (powerUpTimer <= 0 && Math.hypot(px - o.x, py - o.y) < config.r) {
                running = false; document.getElementById('uiOver').classList.remove('hidden');
                document.getElementById('finalScore').textContent = score;
            } else if(o.y < -150) { 
                obstacles.splice(i, 1); updateScore(1); if(score % 5 === 0) speed += 0.2; 
            }
        }

        // ç©å®¶èˆ‡æ•ˆæœ
        updateParticlesLogic();
        ctx.save(); 
        ctx.translate(px, py);
        let tilt = Math.max(-0.2, Math.min(0.2, (tx - px) * 0.05));
        let tipSwing = tilt * 30;
        drawParticlesRelative();
        
        ctx.save(); ctx.strokeStyle = '#3D3333'; ctx.lineWidth = (CHARS[selectedIdx].boardType === 'double') ? 10 : 25; ctx.lineCap = 'round';
        if (CHARS[selectedIdx].boardType === 'double') {
            const gap = 10;
            ctx.beginPath(); ctx.moveTo(-gap, -25); ctx.lineTo(-gap + tipSwing, 25); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(gap, -25); ctx.lineTo(gap + tipSwing, 25); ctx.stroke();
            if (Math.abs(tilt) > 0.05) { addParticle(-gap + tipSwing, 12, -2, 2); addParticle(gap + tipSwing, 12, 2, 2); }
        } else {
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(tipSwing, 24); ctx.stroke();
            if (Math.abs(tilt) > 0.05) addParticle(tipSwing, 25, -tilt * 10, 2);
        }
        ctx.restore();

        ctx.save();
        let breath = Math.sin(frame * 0.15) * 2; 
        ctx.translate(0, breath); ctx.rotate(tilt * 0.5); 
        const charData = CHARS[selectedIdx], charID = charData.file;
        let faceSuffix = (!running) ? "d" : (powerUpTimer > 0) ? "e" : (stormMode) ? "s" : (score > 0 && score % 10 <= 2) ? "h" : "n";
        const bodyImg = charImages[charID], faceImg = charImages[`${charID}_${faceSuffix}`];
        const drawW = charData.size || 70, drawH = (260 / 152) * drawW;

        if (bodyImg && bodyImg.complete) {
            if (powerUpTimer > 0) { ctx.filter = (frame % 4 < 2) ? 'brightness(1.5) sepia(0.5)' : 'none'; ctx.shadowBlur = 15; ctx.shadowColor = "rgba(255, 215, 0, 0.8)"; }
            ctx.drawImage(bodyImg, -drawW/2, -drawH + 5, drawW, drawH);
            ctx.filter = 'none'; ctx.shadowBlur = 0;
            if (faceImg && faceImg.complete && faceSuffix !== 'n') {
                const faceW = drawW * (charData.faceScale || 0.6), faceH = faceImg.height * (faceW / faceImg.width);
                ctx.drawImage(faceImg, (drawW * (charData.faceX || 0)) - faceW / 2, (-drawH * (charData.faceY || 0.75)) - faceH / 2, faceW, faceH);
            }
            if (powerUpTimer > 0) {
// ç„¡æ•µç‹€æ…‹ï¼šé‡‘é»ƒè‰²å­—é«”
            ctx.save();
            // ğŸ’¡ è¨­å®šé™°å½±ï¼šå¢åŠ ç«‹é«”æ„Ÿï¼Œé˜²æ­¢æ–‡å­—æ·¹æ²’åœ¨ç™½è‰²é›ªåœ°
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)"; // é»‘è‰²åŠé€æ˜é™°å½±
            ctx.shadowBlur = 1;                    // æ¨¡ç³Šç¨‹åº¦
            ctx.shadowOffsetX = 1;                 // æ°´å¹³ä½ç§»
            ctx.shadowOffsetY = 1;                 // å‚ç›´ä½ç§»
            
            ctx.fillStyle = '#f0c60c'; 
            ctx.font = `bold ${Math.floor(drawW * 0.3)}px Inter`;
            ctx.textAlign = 'center';

            // ğŸ’¡ èª¿æ•´é«˜åº¦ï¼š-drawH æ˜¯é ­é ‚ï¼Œå¾Œé¢çš„æ•¸å­—æ„ˆå¤§æ„ˆå¾€ä¸Š
            const textY = -drawH - 10; // å¾ -35 æ”¹ç‚º -45ï¼Œè®“å­—é£›æ›´é«˜ä¸€é»
            const textBounce = Math.sin(frame * 0.2) * 5;
            
            ctx.fillText("âœ¨ ç„¡æ•µè¡åˆº âœ¨", 0, textY + textBounce);
            
            // ç•«å¢¨é¡ï¼šç¨å¾®èª¿ä½ä¸€é»é»è²¼è¿‘è‡‰éƒ¨
            ctx.font = `bold ${Math.floor(drawW * 0.35)}px serif`;
            ctx.fillText("ğŸ˜", 0, -drawH + 10); 
            ctx.restore();
            } else if (stormMode) {
// æš´é¢¨é›ªç‹€æ…‹ï¼šç´…è‰²è­¦å‘Šå­—é«”
            ctx.save();
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)"; // æš´é¢¨é›ªæ™‚é™°å½±åŠ æ·±
            ctx.shadowBlur = 4;
            
            ctx.fillStyle = (frame % 20 < 10) ? '#ff4d4d' : '#ffcccc'; 
            ctx.font = `bold ${Math.floor(drawW * 0.3)}px Inter`;
            ctx.textAlign = 'center';
            
            const alertY = -drawH - 10; // è­¦ç¤ºæ–‡å­—é«˜åº¦
            const textShake = (Math.random() - 0.5) * 3;
            ctx.fillText("âš ï¸ æš´é¢¨é›ªä¾†è¥² âš ï¸", textShake, alertY);
            
            ctx.font = `bold ${Math.floor(drawW * 0.35)}px serif`;
            ctx.fillText("ğŸ¥¶", 0, -drawH + 10);
            }
        }
        ctx.restore();

        ctx.fillStyle = '#222222'; let bindSwing = tipSwing * 0.5;
        if (charData.boardType === 'double') {
            ctx.beginPath(); ctx.roundRect(-16 + bindSwing, -7.5, 17, 12, 4); ctx.fill();
            ctx.beginPath(); ctx.roundRect(2 + bindSwing, -7.5, 17, 12, 4); ctx.fill();
        }
        ctx.restore();

        if (stormMode) {
            if (fogAlpha < 0.75) fogAlpha += 0.015;
            for(let i=0; i<15; i++) addStormParticle();
            ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0);
            let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width*0.15, canvas.width/2, canvas.height/2, canvas.width*0.9);
            grad.addColorStop(0, "rgba(255, 255, 255, 0)"); grad.addColorStop(1, `rgba(255, 255, 255, ${fogAlpha})`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.restore();
        } else if (fogAlpha > 0) { fogAlpha -= 0.02; }

        requestAnimationFrame(loop);
    }

    function addParticle(x, y, vx, vy) { if (particles.length < 150) particles.push({ x, y, vx, vy, life: 30, alpha: 1, isStorm: false }); }
    function addStormParticle() { if (particles.length < 350) particles.push({ x: Math.random() * (canvas.width + 600) - 200, y: Math.random() * -200, vx: -15 - Math.random() * 20, vy: 20 + Math.random() * 15, life: 30, alpha: 0.3 + Math.random() * 0.5, isStorm: true, size: 1 + Math.random() * 3 }); }
    function updateParticlesLogic() { for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; if (!p.isStorm) p.y -= speed * 0.5; p.life--; p.alpha = p.life / 30; if (p.life <= 0) particles.splice(i, 1); } }
    function drawParticlesRelative() { particles.forEach(p => { ctx.save(); ctx.globalAlpha = p.alpha; ctx.strokeStyle = 'white'; ctx.fillStyle = 'white'; if (p.isStorm) { ctx.lineWidth = p.size; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + p.vx * 0.8, p.y + p.vy * 0.8); ctx.stroke(); } else { ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }); }

    window.onresize = resize; resize(); initCharSelect();
</script>
</body>
</html>